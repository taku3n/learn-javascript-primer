# 第１部: 基本文法

## JavaScript とは

- そもそも JavaScript とはどんなプログラミング言語なのかの理解が深まった。
- ECMAScript
  - 実行環境によらない共通な動作が定義された仕様。
  - ESMAScript の読み方は"エスマスクリプト"
  - ES2015 以降は毎年新しいバージョンがリリースされている。
  - 最新の仕様書: <https://tc39.es/ecma262/>
    - Living Standard(常に最新版を公開する仕組み) で管理されている。
  - 仕様策定のプロセスは 5 段階(0 から 4 まで)のステージに分かれる
    - ステージ 4 未満の使用は安定していないことが多い
- JavaScript のリファレンスサイト: <https://developer.mozilla.org/ja/>

## コメント

### １行コメント

```js
// １行コメント
```

### 複数行コメント

```js
/*
  複数行
  コメント
*/
```

- 複数行コメントの中に複数行コメントを書くことはできない。

### HTML-like コメント

```js
<!-- この行はコメントと認識される
console.log("この行はJavaScriptのコードとして実行される");
-->  この行もコメントと認識される
```

- 後方互換性のための仕様。
- JavaScript は一度入った仕様が後続のバージョンで使用できなくなることはほとんどないが、その代わり新しい機能は増え続けるため学び続ける必要がある。

## 変数と宣言

- `const`, `let`, `var`,の 3 つの宣言キーワードがある

### const

- 再代入できない変数の宣言と初期値の定義ができる。

```js
const 変数名 = 初期値;
```

- `,`(カンマ)で区切ると複数の変数を設定できる(3 つのキーワード共通)。

```js
const bookTitle = "JavaScript Primer",
  bookCategory = "プログラミング";
```

- const キーワードで定義した変数に後から違う値を代入することはできない(エラーになる)。

```js
const bookTitle = "JavaScript Primer";
bookTitle = "新しいタイトル"; // => TypeError: invalid assignment to const 'bookTitle'
```

- 参照透過性
  - 変数の値は最初に定義した値と常に同じである
- 変数への再代入は参照透過性の掟破りになりバグの温床になるからやめよう。
  - 変数に再代入しないケースは`const`の仕様が推奨されている。

### let

- 値の再代入ができる変数の宣言と初期値の定義ができる。

```js
let 変数名 = 初期値;
```

- 初期値を設定しないことも可能。このときは`undefined`という値で初期化。

```js
let bookTitle;
// `bookTitle`は自動的に`undefined`という値になる
```

- 何度でも再代入が可能。

```js
let count = 0;
count = 1;
count = 2;
count = 3;
```

### var

- 値の再代入が可能な変数の宣言と初期化ができる。
- var の使い方は let とほぼ同じ。

- `const`, `let`との違いは同じ名前の変数の再定義ができる点。

```js
// const, let は同じ名前の変数の再定義ができない(エラー発生)
let x;
// 同じ変数名の変数"x"を定義するとSyntaxErrorとなる
let x; // => SyntaxError: redeclaration of let x

// var は同じ名前の変数の再定義ができてしまう(値を置き換えちゃう)
var x = 1;
// 同じ変数名の変数"x"を定義できる
var x = 2;
// 変数xは2となる
```

- `var`にはさまざまな問題があり、ほぼ全てのケースで`const`か`let`に置き換え可能だから使用しないようにしよう。

### 変数名に使える名前のルール

- 識別子のルール

  1. 半角アルファベット、`_`（アンダースコア）、`$`（ダラー）、数字を組み合わせた名前にする
  2. 数字から始まる名前は使えない
  3. 予約語と被る名前は使えない

- JavaScript では大文字と小文字は区別される。

```js
let $; // OK: $が利用できる
let _title; // OK: _が利用できる
let jquery; // OK: 小文字のアルファベットが利用できる
let TITLE; // OK: 大文字のアルファベットが利用できる
let es2015; // OK: 数字は先頭以外なら利用できる
let 日本語の変数名; // OK: 一部の漢字や日本語も利用できる
```

- 漢字や日本語は利用できるが、環境によって全角文字が混じると使用しにくくなるため非推奨。

- 数字始まりの名前はダメ。

```js
let 1st; // NG: 数字から始まっている
let 123; // NG: 数字のみで構成されている
```

- 予約後(構文として意味を持つキーワード)は使用できない。

```js
let let; // NG: `let`は変数宣言のために予約されているので利用できない
let if; // NG: `if`はif文のために予約されているので利用できない
```

- 予約後の一覧は MDN のドキュメントを参照: <https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Lexical_grammar>

### const は定数ではない

- 定数: 一度定義した名前（変数名）が常に同じ値を示すもの
- プリミティブなデータ: 数値や文字列などオブジェクト以外のデータ
- `const`でプリミティブなデータで初期化すると実質的に定数だが、オブジェクトなども定義可能。

```js
// `const`でオブジェクトを定義している
const object = {
  key: "値",
};
// オブジェクトそのものは変更できてしまう
object.key = "新しい値";
```

- `const`で宣言した変数が常に同じ値を示すとは限らないから、定数とは呼べない。

## 値の評価と表示

- 値の評価: 入力した値を評価してその結果を返すこと
- JavaScript Primer では FireFox の開発者ツールを使用した説明が記載されていたが、手元では Chrome を使ってやってみよう。

### ブラウザで JavaScript を実行する

- REPL(read–eval–print loop): コードを評価してその結果を表示する機能
- Chrome で試してみると、エンターキーを押す前に結果が薄い文字で表示されていて便利。
- REPL ではその REPL を終了するまで const キーワードなどで宣言した変数が残り続けるから注意する。
  - たとえば１行ずつ実行したとしても、`const`で同じ変数名で二度目の変数定義をしようとするとエラーになる。
- ブラウザの開発者ツールだとページをリロードすると REPL がリセットされる。
  - redeclaration（再定義）のエラーが出たらとりあえずリロードしてみる。

### HTML ファイルを作成し JavaScript コードを読み込む方法

- エディタの設定

  - 文字コード: UTF-8
  - 改行コード: LF

- `<script src="./index.js"></script>`により同じディレクトリ内の js ファイルを読み込む。
  - [example/index.js](../example/index.js)
  - [example/index.html](../example/index.html)

### Console API

- ブラウザのコンソールに出力する。
- `console.log(引数)`の引数にコンソール表示したい値を渡すことで、評価結果がコンソールに表示される。

- 先に引数である変数を評価してから、その結果をコンソールに表示することも可能。

```js
const total = 42 + 42;
console.log(total); // => 84
```

- プリントデバッグとしても利用される。

### コードの評価とエラー

- エラーには大きく分けて構文エラーと実行時エラーの 2 種類がある。

### 構文エラー

- コードをパース(解釈)する段階で文法の間違いがあるとプログラムは実行されず構文エラーを返す。

```js
console.log(1; // => SyntaxError: missing ) after argument list
```

> SyntaxError: missing ) after argument list[詳細] index.js:1:13

- 下記のようにエラーの種類・内容・ファイル名・行番号・列番号が記される。

```txt
SyntaxError: missing ) after argument list[詳細] index.js:1:13
^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      ^^^^^^^^　^^^^
エラーの種類                |                        | 　行番号:列番号
                  エラー内容の説明                 ファイル名
```

- Firefox では[詳細]というリンクがエラーメッセージに関する MDN の解説ページへのリンクとなっているらしい。
  - Chrome ではリンクにはなっていなかったが検索すると一番上に同じ MDN の解説ページが表示された。

### 実行時エラー

- プログラムを実行中に発生するエラー。ランタイムエラーとも。

```js
const value = "値";
console.log(x); // => ReferenceError: x is not defined
```

> ReferenceError: x is not defined[詳細] index.js:2:1

- 実行時エラーは構文エラーよりも種類が多い。
- デバッグ: エラーの原因を特定し、修正する作業

### エラーの原因を探すのに参考になるサイト

- [MDN JavaScript エラーリファレンス](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Errors)
  - 構文エラー、実行時エラーの典型例がまとまっている
- エラー部の検索に使えるサイト
  - [google](https://www.google.com/)
  - [github](https://github.com/)
  - [Stack Overflow](https://stackoverflow.com/)

## データ型とリテラル

### データ型

- JavaScript は動的型付け言語。
- 静的型付け言語のような変数の型はないけど、文字列、数値、真偽値といった値の型はあり、データ型と呼んでる。
- プリミティブ型
  - 真偽値や数値などの基本的な値の型。
  - イミュータブル(一回作成するともう型を変更できない)の特性を持つ。
  - 7 つの種類がある。
    - 真偽値(Boolean): `true` か `false`
    - 数値(Number): 42, 3.14 などの数値
    - 巨大な整数(BigInt): 9007199254740992n などの任意精度の整数
      - ES2020 から追加
    - 文字列（String）: "JavaScript" などの文字列
    - undefined: 値が未定義であることを意味
    - null: 値が存在しないことを意味
    - シンボル（Symbol）: 一意で不変な値
      - ES2015 から追加
- オブジェクト
  - プリミティブ型でないもの。
  - オブジェクト、配列、関数、正規表現、Date など
- `typeof` 演算子を使うことでデータ型を調べることができる。
- `typeof`を使用する際の注意
  - `typeof null`が`object`となってしまうのはバグ。
  - プリミティブ型かオブジェクトかを調べるために使用する
    - オブジェクトも配列も全て`object`となっている。
    - 全ての型を調べることはできない。

### リテラル

- リテラル: プログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたもの。

```js
// "と"で囲んだ範囲が文字列リテラル
const str = "こんにちは";
```

- リテラルがないとき
  - その値を作る関数に引数を渡して作成する必要あり。
- リテラルが用意されている型
  - 4 つのプリミティブ型
    - 真偽値
    - 数値
    - 文字列
    - null
  - オブジェクト
    - オブジェクト
    - 配列
    - 正規表現

### 真偽値（Boolean）

- true と false のリテラルがある。

```js
true; // => true
false; // => false
```

### 数値（Number）

- 整数リテラルと浮動小数点数リテラルがある。
- [IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)の倍精度浮動小数として扱われる。
- `2^53-1`までが正確に扱える。

#### 整数リテラル

- 4 種類の整数リテラルがある。
  - 10 進数
    - 数字の組み合わせ
  - 2 進数
    - `0b`（または`0B`）の後ろに、`0`または`1`の数字の組み合わせ
    - ビットを表現する時に利用されることが多い
  - 8 進数
    - `0o`（または`0O`）の後ろに、`0`から`7`までの数字の組み合わせ
    - ファイルのパーミッションを表現するのに利用されることが多い
  - 16 進数
    - `0x`（または`0X`）の後ろに、`0`から`9`までの数字と`a`から`f`または`A`から`F`のアルファベットの組み合わせ
    - 文字のコードポイントや RGB 値の表現に利用されることが多い

#### 浮動小数点数リテラル

- 2 種類の表記
  - `3.14` のような `.`（ドット）を含んだ数値
  - `2e8` のような `e` または `E` を含んだ数値
- 0 からはじまる浮動小数点数は、0 を省略して書ける
  - 省略しない方が良い。`.`はオブジェクトで利用することが多いため。

```js
0.123; // => 0.123
```

- `e`は指数（exponent）の意味。`e`のあとに指数部の値を書く。

```js
2e8; // => 200000000
```

### BigInt

- 数値リテラルが正確に扱える`2^53-1`よりも大きな整数を扱えるように ES2020 で新しく追加されたリテラル。
- 数値の後ろに`n`をつける。

```js
console.log(1n); // => 1n
```

- 数値リテラルで安全に表せる最大の数値は`Number.MAX_SAFE_INTEGER`として定義。

```js
console.log(Number.MAX_SAFE_INTEGER); // => 9007199254740991
```

- `Number.MAX_SAFE_INTEGER`を超えた場合でも BigInt リテラルは扱える。

```js
// 2^53-1より大きな値も扱える
console.log(9007199254740992n); // => 9007199254740992n
```

BigInt は整数を扱うデータ型だから、小数点を含むと構文エラーが返る。

```js
1.2n; // => SyntaxError
```

#### Numeric Separators

- 数値リテラル内の区切り文字として`_`を追加できる。
  - 数値が大きくなるほど、桁数の見間違いが発生してしまう問題を解消するために ES2021 で追加された。
- 1 兆を Numeric Separators を用いて書くと下記のようになる。

```js
1_000_000_000_000;
```

- 評価時には`_`は無視される。
- 整数、浮動小数点、BigInt のリテラル内でのみ利用できる。
- `_`はリテラルの先頭や数値の最後に追加することはできない。

### 文字列

- 同じ記号で囲んだ内容を文字列として扱う。
- ３種類のリテラルがある。
  - `"`: ダブルクォート
  - `'`: シングルクォート
  - `` ` ``: バッククォート

```js
console.log("文字列"); // => "文字列"
console.log("文字列"); // => "文字列"
console.log(`文字列`); // => "文字列"
```

#### ダブルクォートとシングルクォート

- `"`（ダブルクォート）と`'`（シングルクォート）はまったく同じ意味。
- 文字列の中に同じ記号が出現した場合は、 `\'`のように`\`（バックスラッシュ）を使ってエスケープが必要。

```js
'8 o\'clock'; // => "8 o'clock"
```

- 別のクォート記号を使う場合はエスケープは不要。

```js
"8 o'clock"; // => "8 o'clock"
```

- 改行を含むと構文エラー（SyntaxError）になる。
- 改行記号のエスケープシーケンス（\n）を使うと複数行の文字列を書けるが、ES2015 から導入されたテンプレートリテラルを使用するのが推奨。

```js
"複数行の\n文字列を\n入れたい";
```

#### テンプレートリテラル

- `` ` ``（バッククォート）で囲んだ範囲を文字列とするリテラル。
- 複数行の文字列で改行を使用することができる。

```js
`複数行の
文字列を
入れたい`; // => "複数行の\n文字列を\n入れたい"
```

- テンプレートの機能もあり、`${変数名}`で変数の値を埋め込める。

```js
const str = "文字列";
console.log(`これは${str}です`); // => "これは文字列です"
```

- 文字列の中に`` ` ``(バッククォート)を内包したい場合は`\`でエスケープが必要。

```js
`This is \`code\``; // => "This is `code`"
```

### null リテラル

- `null`値(値がないこと)を返すリテラル。
- 未定義の場合は変数を参照できないが、`null`で定義すると参照できる。

```js
const foo = null;
console.log(foo); // => null
```

### undefined はリテラルではない

- `undefined`はただのグローバル変数。
- 同じ undefined という名前のローカル変数を宣言することは可能(非推奨)。

```js
function fn() {
  var undefined = "独自の未定義値"; // undefinedという名前の変数をエラーなく定義できる
  console.log(undefined); // => "独自の未定義値"
}
fn();
```

- それに対しリテラルは変数名に使用すると構文エラーになる。

```js
var null; // => SyntaxError
```

### オブジェクトリテラル

- `{}`（中カッコ）を書くことで、新しいオブジェクトを作成できる。

```js
const obj = {}; // 中身が空のオブジェクトを作成
```

- オブジェクトの作成と同時に中身の定義もできる。
  - キーと値を`:`で区切る。

```js
const obj = {
  key: "value",
};
```

- プロパティ名: オブジェクトが持つキーのこと。

  - 上記の例だと、`obj`というオブジェクトは`key`というプロパティを持つといえる。

- `obj`の`key`プロパティの参照は２種類ある。
  - `.`でつなぐ
    - プロパティ名が識別子である必要がある
  - `[]`（ブラケット）

```js
const obj = {
  key: "value",
};
// ドット記法
console.log(obj.key); // => "value"
// ブラケット記法
console.log(obj["key"]); // => "value"
```

- プロパティ名が識別子でない場合

```js
// プロパティ名は文字列の"123"
var object = {
    "123": "value"
};
// OK: ブラケット記法では、文字列として書くことができる
console.log(object["123"]); // => "value"
// NG: ドット記法では、数値からはじまる識別子は利用できない
object.123
```

### 配列リテラル

- `[`と`]`で値をカンマ区切りで囲み、その値を持つ Array オブジェクトを作成するリテラル。
- 配列（Array オブジェクト）: 複数の値に順序をつけて格納できるオブジェクトの一種。

```js
const emptyArray = []; // 空の配列を作成
const array = [1, 2, 3]; // 値を持った配列を作成
```

- `0`からはじまるインデックスに対応した値を持つ。
- `array[index]`という構文で指定したインデックスの値を参照可能。

```js
const array = ["index:0", "index:1", "index:2"];
// 0番目の要素を参照
console.log(array[0]); // => "index:0"
// 1番目の要素を参照
console.log(array[1]); // => "index:1"
```

### 正規表現リテラル

- `/`（スラッシュ）と`/`（スラッシュ）で正規表現のパターン文字列を囲み、正規表現を表すリテラル。
- 1 文字以上の数字にマッチする正規表現の例は下記のようになる。

```js
const numberRegExp = /\d+/; // 1文字以上の数字にマッチする正規表現
// `numberRegExp`の正規表現が文字列"123"にマッチするかをテストする
console.log(numberRegExp.test("123")); // => true
```

### プリミティブ型とオブジェクト

- リテラルでも表現できる真偽値（Boolean）、数値（Number）、文字列（String）をオブジェクトとして表現する方法がある。
- プリミティブ型の値をラップしたようなオブジェクトであるためラッパーオブジェクトと呼ばれる。
- ラッパーオブジェクトは、
  - `new`演算子と対応するコンストラクタ関数を利用して作成する。
  - 例として、文字列のプリミティブ型に対応するコンストラクタ関数は`String`。
  - `typeof`演算子の結果は`object`となる。
  - `length`プロパティなどのオブジェクトが持つプロパティを参照可能になる。

```js
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3
```

- プリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがある。
  - プリミティブ型のデータのプロパティへアクセスする際に、対応するラッパーオブジェクトへ暗黙的に変換してからプロパティへアクセスするため。

```js
// プリミティブ型の文字列データ
const str = "文字列";
// プリミティブ型の文字列は"string"型のデータ
console.log(typeof str); // => "string"
// プリミティブ型の文字列も`length`プロパティを参照できる
console.log(str.length); // => 3
```

- 常にリテラルでプリミティブ型のデータを表現することを推奨されている。
  - ラッパーオブジェクトを明示的に作成するには、リテラルに比べて冗長な書き方が必要なため。

## 演算子

- 演算子: よく利用する演算処理を記号などで表現したもの。
- 被演算子（オペランド）: 演算子が演算する対象。

```js
1 + 2;
```

- 上記の例では`+`が演算子、`1`, `2`がオペランド。
- 二項演算子: 2 つのオペランドを取る演算子。
  - `左オペランド 演算子 右オペランド`
  - 例えば`+`演算子
- 単項演算子: 1 つのオペランドを取る演算子。
  - 例えば`++`演算子
  - 前後どちらか一方にオペランド
    - 後: `num++;`
    - 前: `++num;`

### 二項演算子

#### プラス演算子（`+`）

- 2 つの数値を加算する演算子。

```js
console.log(1 + 1); // => 2
```

#### 文字列結合演算子（`+`）

- 2 つの文字列を結合した文字列を返す。

```js
const value = "文字列" + "結合";
console.log(value); // => "文字列結合"
```

#### マイナス演算子（`-`）

- 2 つの数値を減算する演算子。

```js
console.log(1 - 1); // => 0
console.log(10 - 0.5); // => 9.5
```

#### 乗算演算子（`*`）

- 2 つの数値を乗算する演算子。

```js
console.log(2 * 8); // => 16
console.log(10 * 0.5); // => 5
```

#### 除算演算子（`/`）

- 2 つの数値を除算する演算子。
- 左オペランドを右オペランドで除算した値を返す。

```js
console.log(8 / 2); // => 4
console.log(10 / 0.5); // => 20
```

#### 剰余演算子(`%`)

- 2 つの数値のあまりを求める演算子。
- 左オペランドを右オペランドで除算したあまりを返す。

```js
console.log(8 % 2); // => 0
console.log(9 % 2); // => 1
console.log(10 % 0.5); // => 0
console.log(10 % 4.5); // => 1
```

#### べき乗演算子（`**`）

- ES2016 で追加された演算子。
- 2 つの数値のべき乗を求める演算子。
- 左オペランドを右オペランドでべき乗した値を返す。
- べき乗演算子と同じ動作をする`Math.pow`メソッドがある。

```js
// べき乗演算子（ES2016）で2の4乗を計算
console.log(2 ** 4); // => 16
```

### 単項演算子（算術）

#### 単項プラス演算子（`+`）

- 単項演算子の`+`はオペランドを数値に変換する。
- 文字列型の数字は数値に変換される。

```js
console.log(+"1"); // => 1
```

- 数値に変換できない文字列などは `NaN` という特殊な値へと変換される(非推奨)。
  - `NaN`: "Not-a-Number"の略。
  - 数値ではないが Number 型の値であることを表す。
  - `NaN`はどの値とも（`NaN` 自身に対しても）一致しない。
  - `Number.isNaN` メソッドを使うことで `NaN` の判定ができる。

```js
// 数値ではない文字列はNaNという値に変換される
console.log(+"文字列"); // => NaN

// 自分自身とも一致しない
console.log(NaN === NaN); // => false
// Number型である
console.log(typeof NaN); // => "number"
// Number.isNaNでNaNかどうかを判定
console.log(Number.isNaN(NaN)); // => true
```

- 文字列から数値への変換は`Number`コンストラクタ関数や`parseInt`関数などの明示的な変換方法を使用するべき。

#### 単項マイナス演算子（-）

- 単項マイナス演算子はマイナスの数値を記述する際に使用。

```js
console.log(-1); // => -1
```

- マイナスの数値を反転することもできる。

```js
console.log(-(-1)); // => 1
```

- 文字列を数値に変換できる点や変換できない文字列には`NaN`を返す点は単項プラス演算子同様。

#### インクリメント演算子（++）

- オペランドの数値を+1 する演算子。
- オペランドの後ろに置くか前に置くかで、それぞれで評価の順番が異なる。
- 後置インクリメント演算子（num++）は評価結果を返した後に`+1`する

```js
let x = 1;
console.log(x++); // => 1
console.log(x); // => 2
```

- 前置インクリメント演算子（++num）は評価結果を返す前に`+1`する

```js
let x = 1;
console.log(++x); // => 2
console.log(x); // => 2
```

#### デクリメント演算子（`--`）

- オペランドの数値を`-1`する演算子

### 比較演算子

#### 厳密等価演算子（`===`）

- 同じ型で同じ値である場合に、`true`を返す

```js
console.log(1 === 1); // => true
console.log(1 === "1"); // => false
```

- オペランドがどちらもオブジェクトであるときは、 オブジェクトの参照が同じである場合に、true を返す。

```js
// {} は新しいオブジェクトを作成している
const objA = {};
const objB = {};
// 生成されたオブジェクトは異なる参照となる
console.log(objA === objB); // => false
// 同じ参照を比較している場合
console.log(objA === objA); // => true
```

#### 厳密不等価演算子（`!==`）

- 異なる型または異なる値である場合に、`true`を返す。
- `===`を反転した結果を返す演算子。

### 等価演算子（`==`）

- 2 つのオペランドを比較する(非推奨)。
- オペランド同士が異なる型の値であった場合に、 同じ型となるように暗黙的な型変換をしてから比較する。

```js
// 文字列を数値に変換してから比較
console.log(1 == "1"); // => true
// "01"を数値にすると`1`となる
console.log(1 == "01"); // => true
// 真偽値を数値に変換してから比較
console.log(0 == false); // => true
// nullの比較はfalseを返す
console.log(0 == null); // => false
// nullとundefinedの比較は常にtrueを返す
console.log(null == undefined); // => true
```

- 上記のように見た目から予測できない挙動が多いため非推奨

  - 厳密等価演算子（`===`）を使い、異なる型を比較したい場合は明示的に型を合わせるべき。

- 例外的に、等価演算子（==）が使われるケース
  - `null`と`undefined`の比較
  - 比較したいオペランドが null または undefined であることを判定したい場合は厳密等価演算子（`===`）では二度の比較が必要

```js
const value = undefined; /* または null */
// === では2つの値と比較しないといけない
if (value === null || value === undefined) {
  console.log("valueがnullまたはundefinedである場合の処理");
}
// == では null と比較するだけでよい
if (value == null) {
  console.log("valueがnullまたはundefinedである場合の処理");
}
```

#### 不等価演算子（`!=`）

- 2 つのオペランドを比較し、等しくないなら true を返す。
- 等価演算子（`==`）と同様に暗黙的な型変換をしてから比較するため使用しないことが推奨。

#### 大なり演算子/より大きい（`>`）

- 左オペランドが右オペランドより大きいならば、true を返す。

```js
console.log(42 > 21); // => true
console.log(42 > 42); // => false
```

#### 大なりイコール演算子/以上（`>=`）

- 左オペランドが右オペランドより大きいまたは等しいならば、true を返す。

#### 小なり演算子/より小さい（`<`）

- 左オペランドが右オペランドより小さいならば、true を返す。

#### 小なりイコール演算子/以下（`<=`）

- 左オペランドが右オペランドより小さいまたは等しいならば、true を返す。

### ビット演算子

- オペランドである数値を符号付き 32 ビット整数（0 と 1 からなる 32 個のビットの集合）として扱う。
  - 例えば、`1`という数値は符号付き 32 ビット整数のビットでは、`00000000000000000000000000000001` と表す。
- 負の数値は、2 の補数形式で表現される。
  - 例えば、`-1` という数値の符号付き 32 ビット整数のビットでは`1111_1111_1111_1111_1111_1111_1111_1111`と表す。

#### ビット論理積（`&`）

- ビットごとの AND 演算した結果を返す。

```js
console.log(15 & 9); // => 9
// 同じ位の各ビット同士をAND演算する（上位の`0`は省略）
// 1111
// 1001
// ----
// 1001
console.log(0b1111 & 0b1001); // => 0b1001
```

#### ビット論理和（`|`）

- ビットごとの OR 演算した結果を返す。

#### ビット排他的論理和（`^`）

- ビットごとの XOR 演算した結果を返す。

#### ビット否定（`~`）

- オペランドの各ビットを反転した値を返す。
- ビット演算以外の用途に使用される。
  - `~x`のように`x`をビット否定演算子で演算した結果は、`-(x + 1)`となる。
  - 文字列（`String`オブジェクト）が持つ`indexOf`メソッドでは検索対象が見つからない場合には-1 を返す。

```js
const str = "森森本森森";
// 見つかった場合はインデックスを返す
// JavaScriptのインデックスは0から開始するので2を返す
console.log(str.indexOf("本")); // => 2
// 見つからない場合は-1を返す
console.log(str.indexOf("火")); // => -1
```

- 否定演算子（`~`）と`indexOf`メソッドを使ったイディオムが一部では使われていた。

```js
const str = "森森木森森";
// indexOfメソッドは見つからなかった場合は -1 を返す
if (str.indexOf("木") !== -1) {
  console.log("木を見つけました");
}
// 否定演算子（`~`）で同じ動作を実装
// (~(-1)) は 0 となるため、見つからなかった場合はif文の中身は実行されない
if (~str.indexOf("木")) {
  console.log("木を見つけました");
}
```

- ES2015 以降は`includes`メソッドが実装された。
  - 否定演算子（`~`）と `indexOf` メソッドを使ったイディオムは、includes メソッドに置き換え可能。

#### 左シフト演算子（`<<`）

- 数値である num を bit の数だけ左へシフトする。

#### 右シフト演算子（`>>`)

- 数値である num を bit の数だけ右へシフトし、あふれたビットは破棄され、左端のビットのコピーを左から詰める。

#### ゼロ埋め右シフト演算子（`>>>`）

- 数値である num を bit の数だけ右へシフトし、右にあふれたビットは破棄され、0 のビットを左から詰める。

#### 代入演算子（`=`）

- 変数に対して値を代入する。
- 二項演算子と組み合わせることもできる。

#### 分割代入（Destructuring assignment）

- 配列やオブジェクトの値を複数の変数へ同時に代入する短縮記法。
- ES2015 から導入された。

- 配列はこう書ける。

```js
const array = [1, 2];
// aには`array`の0番目の値、bには1番目の値が代入される
const [a, b] = array;
console.log(a); // => 1
console.log(b); // => 2
```

- オブジェクトはこう書ける。

```js
const obj = {
  key: "value",
};
// プロパティ名`key`の値を、変数`key`として定義する
const { key } = obj;
console.log(key); // => "value"
```

### 論理演算子

#### AND 演算子（`&&`）

- 左辺の値の評価結果が `true` ならば、右辺の評価結果を返す。
- 左辺の値の評価結果が `false` ならば、そのまま左辺の値を返す。

- 短絡評価: 値が決まった時点でそれ以上評価しないこと。

```js
// 左辺がtrueなので、右辺は評価される
true && console.log("このコンソールログは実行されます");
// 左辺がfalseなので、右辺は評価されない
false && console.log("このコンソールログは実行されません");
```

- 左辺を評価する際に、左辺を真偽値へと暗黙的な型変換をしてから判定する。
- 真偽値への暗黙的な型変換でどの値が true でどの値が false になるかの条件
  - falsy な値は`false`になる
  - falsy でない値は`true`になる
- falsy な値とは次の 7 種類

  - `false`
  - `undefined`
  - `null`
  - `0`
  - `0n`
  - `NaN`
  - `""`（空文字列）

- 左辺が falsy の場合は、右辺は評価されない。

```js
// 左辺はfalsyではないため、評価結果として右辺を返す
console.log("文字列" && "右辺の値"); // => "右辺の値"
console.log(42 && "右辺の値"); // => "右辺の値"
// 左辺がfalsyであるため、評価結果として左辺を返す
console.log("" && "右辺の値"); // => ""
console.log(0 && "右辺の値"); // => 0
console.log(null && "右辺の値"); // => null
```

- AND 演算子は、if 文と組み合わせて利用することが多い。
  - 例えば、value が`String`型で かつ 値が`"str"`である場合という条件をひとつの式として書ける。
  - AND 演算子（&&）を使うと、if 文のネストに比べて短く書ける。
  - AND 演算子や OR 演算子が 3 つ 4 つ連続すると複雑で読みにくいコードになるので抽象化を検討する。

```js
const value = "str";
if (typeof value === "string" && value === "str") {
  console.log(`${value} is string value`);
}
// if文のネストで書いた場合と結果は同じとなる
if (typeof value === "string") {
  if (value === "str") {
    console.log(`${value} is string value`);
  }
}
```

#### OR 演算子（`||`）

- OR 演算子（||）は、左辺の値の評価結果が true ならば、そのまま左辺の値を返す。
- 左辺の値の評価結果が false であるならば、右辺の評価結果を返す。

#### NOT 演算子（`!`）

- オペランドの評価結果を反転した真偽値を返す。
- 真偽値へと暗黙的な型変換する。
  - falsy である値は true へ変換され、falsy ではない値は false へと変換される。

```js
// falsyな値は`true`となる
console.log(!0); // => true
console.log(!""); // => true
console.log(!null); // => true
// falsyではない値は`false`となる
console.log(!42); // => false
console.log(!"文字列"); // => false
```

- 2 つ NOT 演算子を重ねて真偽値へ変換するという使い方もある(非推奨)。
  - 多くは、比較演算子を使うなどより明示的な方法で、真偽値を得ることができるため別の方法を探そう。

```js
const str = "";
// 空文字列はfalsyであるため、true -> falseへと変換される(非推奨)
console.log(!!str); // => false

// 空文字列(長さが0より大きな文字列)でないことを判定(こう書くべき)
console.log(str.length > 0); // => false
```

#### Nullish coalescing 演算子(`??`)

- 左辺の値が nullish であるならば、右辺の評価結果を返す。
- ES2020 で導入された。
- `nullish`: 評価結果が`null`または`undefined`となる値のこと。
- 読み方はヌリッシュコアレシングオペレーター。
- 値のデフォルト値を指定する場合によく利用される。

- OR 演算子（`||`）は左辺が falsy の場合に右辺を評価するため、意図しない結果になるケースがある。

```js
const inputValue = 任意の値または未定義;
// `inputValue`がfalsyの場合は、`value`には`42`が入る
// `inputValue`が`0`の場合は、`value`に`42`が入ってしまう
const value = inputValue || 42;
console.log(value);
```

- Nullish coalescing 演算子(??)では`0`が inputValue となっても正しくデフォルト値に設定できる。

```js
const inputValue = 任意の値または未定義;
// `inputValue`がnullishの場合は、`value`には42が入る
// `inputValue`が`0`の場合は、`value`に`0`が入る
const value = inputValue ?? 42;
console.log(value);
```

### 条件（三項）演算子（`?`と`:`）

- 条件式を評価した結果が`true`ならば、True のとき処理する式の評価結果を返す。
- 条件式を評価した結果が`false`である場合は、False のとき処理する式の評価結果を返す。

```js
条件式 ? Trueのとき処理する式 : Falseのとき処理する式;
```

- 条件分岐による値を返せるため、条件によって変数の初期値が違う場合などに使われる。

```js
function addPrefix(text, prefix) {
  // `prefix`が指定されていない場合は"デフォルト:"を付ける
  const pre = typeof prefix === "string" ? prefix : "デフォルト:";
  return pre + text;
}

console.log(addPrefix("文字列")); // => "デフォルト:文字列"
console.log(addPrefix("文字列", "カスタム:")); // => "カスタム:文字列"
```

- if 文を使った場合は、宣言と代入を分ける必要があるため、const が使えない。

```js
function addPrefix(text, prefix) {
  let pre = "デフォルト:";
  if (typeof prefix === "string") {
    pre = prefix;
  }
  return pre + text;
}

console.log(addPrefix("文字列")); // => "デフォルト:文字列"
console.log(addPrefix("文字列", "カスタム:")); // => "カスタム:文字列"
```

### グループ化演算子（`(`と`)`）

- 複数の二項演算子が組み合わさった場合に、演算子の優先順位を明示できる演算子。

```js
const a = 1;
const b = 2;
const c = 3;
console.log(a + b * c); // 7
console.log((a + b) * c); // => 9
```

- ひとつの式に複数の種類の演算子が出てくると読みにくくなるのでグループ化演算子で結合順を明示してかく。

```js
if (x || (y && z)) {
  // x が true または
  // y かつ z が true
}
```

- ひとつの式で多数の演算をするよりも、式自体を分けたほうが読みやすいこともある。

```js
// 読みにくい例
if (
  (typeof a === "string" && typeof b === "string") ||
  (typeof x === "number" && typeof y === "number")
) {
  // `a`と`b`が文字列型 または
  // `x`と`y`が数値型
}

// 読みやすい例
const isAbString = typeof a === "string" && typeof b === "string";
const isXyNumber = typeof x === "number" && typeof y === "number";
if (isAbString || isXyNumber) {
  // `a`と`b`が文字列型 または
  // `x`と`y`が数値型
}
```

- それぞれの条件を分解して名前をつける（変数として定義する）ことも重要。

### カンマ演算子（`,`）

- カンマ（`,`）で区切った式を左から順に評価し、 最後の式の評価結果を返す。
- 利用する機会はほとんどない。

```js
式1, 式2, 式3;
```

- 上記の例だと、式 1、式 2、式 3 の順に評価され、式 3 の評価結果を返す。
- const による変数宣言時にカンマで区切るのはカンマ演算子ではない。

## 暗黙的な型変換

- 厳密等価演算子（`===`）は暗黙的な型変換をしない(推奨)
- 等価演算子（`==`）は暗黙的な型変換をする(非推奨)

```js
// `==`では、異なるデータ型は暗黙的な型変換をしてから比較される
// 暗黙的な型変換によって 1 == 1 のように変換されてから比較される
console.log(1 == "1"); // => true
```

- 数値と真偽値の加算も暗黙的な型変換をする

```js
// 暗黙的な型変換が行われ、数値の加算として計算される
1 + true; // => 2
// 次のように暗黙的に変換されてから計算される
1 + 1; // => 2
```

### 暗黙的な型変換とは

- ある処理において、その処理過程で行われる明示的ではない型変換のこと。

#### 等価演算子の暗黙的な型変換

- 比較前にオペランド同士が同じ型となるように暗黙的な型変換する。

```js
// 異なる型である場合に暗黙的な型変換が行われる
console.log(1 == "1"); // => true
console.log(0 == false); // => true
console.log(10 == ["10"]); // => true
```

### 明示的な型変換

#### 任意の値 → 真偽値

- Boolean コンストラクタ関数
  - falsy な値は`false`になる。
  - falsy でない値は`true`になる。

#### 数値 → 文字列

- String コンストラクタ関数
  - 数値以外にもいろいろな値を文字列へと変換できる。
  - オブジェクトに対しては、あまり意味のある文字列を返さないため、使用はあくまでプリミティブ型に留める。

```js
String(1); // => "1"
String("str"); // => "str"
String(true); // => "true"
String(null); // => "null"
String(undefined); // => "undefined"
String(Symbol("シンボルの説明文")); // => "Symbol(シンボルの説明文)"
// プリミティブ型ではない値の場合
String([1, 2, 3]); // => "1,2,3"
String({ key: "value" }); // => "[object Object]"
String(function () {}); // "function() {}"
```

#### シンボル → 文字列

- ES2015 で追加されたプリミティブ型であるシンボルは暗黙的に型変換できない。

```js
"文字列と" + Symbol("シンボルの説明"); // => TypeError: can't convert symbol to string
```

- String コンストラクタ関数を使うと明示的に型変換できる。

```js
"文字列と" + String(Symbol("シンボルの説明")); // => "文字列とSymbol(シンボルの説明)"
```

#### 文字列 → 数値

- Number コンストラクタ関数
  - 例えばユーザー入力は文字列でしか受け取ることができないため、それを数値に変換する時に使う。

```js
// ユーザー入力を文字列として受け取る
const input = window.prompt("数字を入力してください", "42");
// 文字列を数値に変換する
const num = Number(input);
console.log(typeof num); // => "number"
console.log(num); // 入力された文字列を数値に変換したもの
```

- Number.parseInt
  - 文字列から整数を取り出す。
- Number.parseFloat
  - 文字列から浮動小数点数を取り出す。

```js
// "1"をパースして10進数として取り出す
console.log(Number.parseInt("1", 10)); // => 1
// 余計な文字は無視してパースした結果を返す
console.log(Number.parseInt("42px", 10)); // => 42
console.log(Number.parseInt("10.5", 10)); // => 10
// 文字列をパースして浮動小数点数として取り出す
console.log(Number.parseFloat("1")); // => 1
console.log(Number.parseFloat("42.5px")); // => 42.5
console.log(Number.parseFloat("10.5")); // => 10.5
```

- 数字以外の文字列を渡すと`NaN`が返る。

```js
// 数字ではないため、数値へは変換できない
Number("文字列"); // => NaN
// 未定義の値はNaNになる
Number(undefined); // => NaN
```

- NaN になってしまった場合の処理を書く必要がある。

```js
const userInput = "任意の文字列";
const num = Number.parseInt(userInput, 10);
if (Number.isNaN(num)) {
  console.log("パースした結果NaNになった", num);
}
```

#### NaN は Not a Number だけど Number 型

- 互換性のない性質のデータを明示的に変換したとしても結果は NaN になる。

```js
Number({}); // => NaN
```

- NaN は何と演算しても結果は NaN になる。

```js
const x = 10;
const y = x + NaN;
const z = y + 20;
console.log(x); // => 10
console.log(y); // => NaN
console.log(z); // => NaN
```

- NaN は number 型。

```js
// NaNはnumber型
console.log(typeof NaN); // => "number"
```

- NaN は自分自身と一致しない。

```js
function isNaN(x) {
  // NaNは自分自身と一致しない
  return x !== x;
}
console.log(isNaN(1)); // => false
console.log(isNaN("str")); // => false
console.log(isNaN({})); // => false
console.log(isNaN([])); // => false
console.log(isNaN(NaN)); // => true

// Number.isNaN(x)メソッド
Number.isNaN(NaN); // => true
```

- NaN は暗黙的な型変換の中でももっとも避けたい値。

  - NaN は何と演算しても結果が NaN となってしまうためデバッグが難しいため。

- 関数で意図しない NaN への変換を避ける方法は 2 つ。
  - 呼ばれる側で、Number 型の値以外を受けつけなくする。
  - 呼び出す側で、Number 型の値のみを渡すようにする。
  - どちらも行うことがより安全なコードにつながる。

### 明示的な変換でも解決しないこと

- 例えば、空文字列かどうかを判定するとき
  - 明示的に Boolean コンストラクタ関数で真偽値へ変換するだけだと、0 も空文字列となってしまう(falsy だから)。
  - 空文字列とは「String 型で文字長が 0 の値」であると定義するとより正確に書ける。
  - 型変換をする前にまず別の方法で解決できないかを考えることも大切。
