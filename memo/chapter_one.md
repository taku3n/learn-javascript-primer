# 第１部: 基本文法

## JavaScript とは

- そもそも JavaScript とはどんなプログラミング言語なのかの理解が深まった。
- ECMAScript
  - 実行環境によらない共通な動作が定義された仕様。
  - ESMAScript の読み方は"エスマスクリプト"
  - ES2015 以降は毎年新しいバージョンがリリースされている。
  - 最新の仕様書: <https://tc39.es/ecma262/>
    - Living Standard(常に最新版を公開する仕組み) で管理されている。
  - 仕様策定のプロセスは 5 段階(0 から 4 まで)のステージに分かれる
    - ステージ 4 未満の使用は安定していないことが多い
- JavaScript のリファレンスサイト: <https://developer.mozilla.org/ja/>

## コメント

### １行コメント

```js
// １行コメント
```

### 複数行コメント

```js
/*
  複数行
  コメント
*/
```

- 複数行コメントの中に複数行コメントを書くことはできない。

### HTML-like コメント

```js
<!-- この行はコメントと認識される
console.log("この行はJavaScriptのコードとして実行される");
-->  この行もコメントと認識される
```

- 後方互換性のための仕様。
- JavaScript は一度入った仕様が後続のバージョンで使用できなくなることはほとんどないが、その代わり新しい機能は増え続けるため学び続ける必要がある。

## 変数と宣言

- `const`, `let`, `var`,の 3 つの宣言キーワードがある

### const

- 再代入できない変数の宣言と初期値の定義ができる。

```js
const 変数名 = 初期値;
```

- `,`(カンマ)で区切ると複数の変数を設定できる(3 つのキーワード共通)。

```js
const bookTitle = "JavaScript Primer",
  bookCategory = "プログラミング";
```

- const キーワードで定義した変数に後から違う値を代入することはできない(エラーになる)。

```js
const bookTitle = "JavaScript Primer";
bookTitle = "新しいタイトル"; // => TypeError: invalid assignment to const 'bookTitle'
```

- 参照透過性
  - 変数の値は最初に定義した値と常に同じである
- 変数への再代入は参照透過性の掟破りになりバグの温床になるからやめよう。
  - 変数に再代入しないケースは`const`の仕様が推奨されている。

### let

- 値の再代入ができる変数の宣言と初期値の定義ができる。

```js
let 変数名 = 初期値;
```

- 初期値を設定しないことも可能。このときは`undefined`という値で初期化。

```js
let bookTitle;
// `bookTitle`は自動的に`undefined`という値になる
```

- 何度でも再代入が可能。

```js
let count = 0;
count = 1;
count = 2;
count = 3;
```

### var

- 値の再代入が可能な変数の宣言と初期化ができる。
- var の使い方は let とほぼ同じ。

- `const`, `let`との違いは同じ名前の変数の再定義ができる点。

```js
// const, let は同じ名前の変数の再定義ができない(エラー発生)
let x;
// 同じ変数名の変数"x"を定義するとSyntaxErrorとなる
let x; // => SyntaxError: redeclaration of let x

// var は同じ名前の変数の再定義ができてしまう(値を置き換えちゃう)
var x = 1;
// 同じ変数名の変数"x"を定義できる
var x = 2;
// 変数xは2となる
```

- `var`にはさまざまな問題があり、ほぼ全てのケースで`const`か`let`に置き換え可能だから使用しないようにしよう。

### 変数名に使える名前のルール

- 識別子のルール

  1. 半角アルファベット、`_`（アンダースコア）、`$`（ダラー）、数字を組み合わせた名前にする
  2. 数字から始まる名前は使えない
  3. 予約語と被る名前は使えない

- JavaScript では大文字と小文字は区別される。

```js
let $; // OK: $が利用できる
let _title; // OK: _が利用できる
let jquery; // OK: 小文字のアルファベットが利用できる
let TITLE; // OK: 大文字のアルファベットが利用できる
let es2015; // OK: 数字は先頭以外なら利用できる
let 日本語の変数名; // OK: 一部の漢字や日本語も利用できる
```

- 漢字や日本語は利用できるが、環境によって全角文字が混じると使用しにくくなるため非推奨。

- 数字始まりの名前はダメ。

```js
let 1st; // NG: 数字から始まっている
let 123; // NG: 数字のみで構成されている
```

- 予約後(構文として意味を持つキーワード)は使用できない。

```js
let let; // NG: `let`は変数宣言のために予約されているので利用できない
let if; // NG: `if`はif文のために予約されているので利用できない
```

- 予約後の一覧は MDN のドキュメントを参照: <https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Lexical_grammar>

### const は定数ではない

- 定数: 一度定義した名前（変数名）が常に同じ値を示すもの
- プリミティブなデータ: 数値や文字列などオブジェクト以外のデータ
- `const`でプリミティブなデータで初期化すると実質的に定数だが、オブジェクトなども定義可能。

```js
// `const`でオブジェクトを定義している
const object = {
  key: "値",
};
// オブジェクトそのものは変更できてしまう
object.key = "新しい値";
```

- `const`で宣言した変数が常に同じ値を示すとは限らないから、定数とは呼べない。

## 値の評価と表示

- 値の評価: 入力した値を評価してその結果を返すこと
- JavaScript Primer では FireFox の開発者ツールを使用した説明が記載されていたが、手元では Chrome を使ってやってみよう。

### ブラウザで JavaScript を実行する

- REPL(read–eval–print loop): コードを評価してその結果を表示する機能
- Chrome で試してみると、エンターキーを押す前に結果が薄い文字で表示されていて便利。
- REPL ではその REPL を終了するまで const キーワードなどで宣言した変数が残り続けるから注意する。
  - たとえば１行ずつ実行したとしても、`const`で同じ変数名で二度目の変数定義をしようとするとエラーになる。
- ブラウザの開発者ツールだとページをリロードすると REPL がリセットされる。
  - redeclaration（再定義）のエラーが出たらとりあえずリロードしてみる。

### HTML ファイルを作成し JavaScript コードを読み込む方法

- エディタの設定

  - 文字コード: UTF-8
  - 改行コード: LF

- `<script src="./index.js"></script>`により同じディレクトリ内の js ファイルを読み込む。
  - [example/index.js](../example/index.js)
  - [example/index.html](../example/index.html)

### Console API

- ブラウザのコンソールに出力する。
- `console.log(引数)`の引数にコンソール表示したい値を渡すことで、評価結果がコンソールに表示される。

- 先に引数である変数を評価してから、その結果をコンソールに表示することも可能。

```js
const total = 42 + 42;
console.log(total); // => 84
```

- プリントデバッグとしても利用される。

### コードの評価とエラー

- エラーには大きく分けて構文エラーと実行時エラーの 2 種類がある。

### 構文エラー

- コードをパース(解釈)する段階で文法の間違いがあるとプログラムは実行されず構文エラーを返す。

```js
console.log(1; // => SyntaxError: missing ) after argument list
```

> SyntaxError: missing ) after argument list[詳細] index.js:1:13

- 下記のようにエラーの種類・内容・ファイル名・行番号・列番号が記される。

```txt
SyntaxError: missing ) after argument list[詳細] index.js:1:13
^^^^^^^^^^^  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^      ^^^^^^^^　^^^^
エラーの種類                |                        | 　行番号:列番号
                  エラー内容の説明                 ファイル名
```

- Firefox では[詳細]というリンクがエラーメッセージに関する MDN の解説ページへのリンクとなっているらしい。
  - Chrome ではリンクにはなっていなかったが検索すると一番上に同じ MDN の解説ページが表示された。

### 実行時エラー

- プログラムを実行中に発生するエラー。ランタイムエラーとも。

```js
const value = "値";
console.log(x); // => ReferenceError: x is not defined
```

> ReferenceError: x is not defined[詳細] index.js:2:1

- 実行時エラーは構文エラーよりも種類が多い。
- デバッグ: エラーの原因を特定し、修正する作業

### エラーの原因を探すのに参考になるサイト

- [MDN JavaScript エラーリファレンス](https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Errors)
  - 構文エラー、実行時エラーの典型例がまとまっている
- エラー部の検索に使えるサイト
  - [google](https://www.google.com/)
  - [github](https://github.com/)
  - [Stack Overflow](https://stackoverflow.com/)

## データ型とリテラル

### データ型

- JavaScript は動的型付け言語。
- 静的型付け言語のような変数の型はないけど、文字列、数値、真偽値といった値の型はあり、データ型と呼んでる。
- プリミティブ型
  - 真偽値や数値などの基本的な値の型。
  - イミュータブル(一回作成するともう型を変更できない)の特性を持つ。
  - 7 つの種類がある。
    - 真偽値(Boolean): `true` か `false`
    - 数値(Number): 42, 3.14 などの数値
    - 巨大な整数(BigInt): 9007199254740992n などの任意精度の整数
      - ES2020 から追加
    - 文字列（String）: "JavaScript" などの文字列
    - undefined: 値が未定義であることを意味
    - null: 値が存在しないことを意味
    - シンボル（Symbol）: 一意で不変な値
      - ES2015 から追加
- オブジェクト
  - プリミティブ型でないもの。
  - オブジェクト、配列、関数、正規表現、Date など
- `typeof` 演算子を使うことでデータ型を調べることができる。
- `typeof`を使用する際の注意
  - `typeof null`が`object`となってしまうのはバグ。
  - プリミティブ型かオブジェクトかを調べるために使用する
    - オブジェクトも配列も全て`object`となっている。
    - 全ての型を調べることはできない。

### リテラル

- リテラル: プログラム上で数値や文字列など、データ型の値を直接記述できるように構文として定義されたもの。

```js
// "と"で囲んだ範囲が文字列リテラル
const str = "こんにちは";
```

- リテラルがないとき
  - その値を作る関数に引数を渡して作成する必要あり。
- リテラルが用意されている型
  - 4 つのプリミティブ型
    - 真偽値
    - 数値
    - 文字列
    - null
  - オブジェクト
    - オブジェクト
    - 配列
    - 正規表現

### 真偽値（Boolean）

- true と false のリテラルがある。

```js
true; // => true
false; // => false
```

### 数値（Number）

- 整数リテラルと浮動小数点数リテラルがある。
- [IEEE 754](https://ja.wikipedia.org/wiki/IEEE_754)の倍精度浮動小数として扱われる。
- `2^53-1`までが正確に扱える。

#### 整数リテラル

- 4 種類の整数リテラルがある。
  - 10 進数
    - 数字の組み合わせ
  - 2 進数
    - `0b`（または`0B`）の後ろに、`0`または`1`の数字の組み合わせ
    - ビットを表現する時に利用されることが多い
  - 8 進数
    - `0o`（または`0O`）の後ろに、`0`から`7`までの数字の組み合わせ
    - ファイルのパーミッションを表現するのに利用されることが多い
  - 16 進数
    - `0x`（または`0X`）の後ろに、`0`から`9`までの数字と`a`から`f`または`A`から`F`のアルファベットの組み合わせ
    - 文字のコードポイントや RGB 値の表現に利用されることが多い

#### 浮動小数点数リテラル

- 2 種類の表記
  - `3.14` のような `.`（ドット）を含んだ数値
  - `2e8` のような `e` または `E` を含んだ数値
- 0 からはじまる浮動小数点数は、0 を省略して書ける
  - 省略しない方が良い。`.`はオブジェクトで利用することが多いため。

```js
0.123; // => 0.123
```

- `e`は指数（exponent）の意味。`e`のあとに指数部の値を書く。

```js
2e8; // => 200000000
```

### BigInt

- 数値リテラルが正確に扱える`2^53-1`よりも大きな整数を扱えるように ES2020 で新しく追加されたリテラル。
- 数値の後ろに`n`をつける。

```js
console.log(1n); // => 1n
```

- 数値リテラルで安全に表せる最大の数値は`Number.MAX_SAFE_INTEGER`として定義。

```js
console.log(Number.MAX_SAFE_INTEGER); // => 9007199254740991
```

- `Number.MAX_SAFE_INTEGER`を超えた場合でも BigInt リテラルは扱える。

```js
// 2^53-1より大きな値も扱える
console.log(9007199254740992n); // => 9007199254740992n
```

BigInt は整数を扱うデータ型だから、小数点を含むと構文エラーが返る。

```js
1.2n; // => SyntaxError
```

#### Numeric Separators

- 数値リテラル内の区切り文字として`_`を追加できる。
  - 数値が大きくなるほど、桁数の見間違いが発生してしまう問題を解消するために ES2021 で追加された。
- 1 兆を Numeric Separators を用いて書くと下記のようになる。

```js
1_000_000_000_000;
```

- 評価時には`_`は無視される。
- 整数、浮動小数点、BigInt のリテラル内でのみ利用できる。
- `_`はリテラルの先頭や数値の最後に追加することはできない。

### 文字列

- 同じ記号で囲んだ内容を文字列として扱う。
- ３種類のリテラルがある。
  - `"`: ダブルクォート
  - `'`: シングルクォート
  - `` ` ``: バッククォート

```js
console.log("文字列"); // => "文字列"
console.log("文字列"); // => "文字列"
console.log(`文字列`); // => "文字列"
```

#### ダブルクォートとシングルクォート

- `"`（ダブルクォート）と`'`（シングルクォート）はまったく同じ意味。
- 文字列の中に同じ記号が出現した場合は、 `\'`のように`\`（バックスラッシュ）を使ってエスケープが必要。

```js
'8 o\'clock'; // => "8 o'clock"
```

- 別のクォート記号を使う場合はエスケープは不要。

```js
"8 o'clock"; // => "8 o'clock"
```

- 改行を含むと構文エラー（SyntaxError）になる。
- 改行記号のエスケープシーケンス（\n）を使うと複数行の文字列を書けるが、ES2015 から導入されたテンプレートリテラルを使用するのが推奨。

```js
"複数行の\n文字列を\n入れたい";
```

#### テンプレートリテラル

- `` ` ``（バッククォート）で囲んだ範囲を文字列とするリテラル。
- 複数行の文字列で改行を使用することができる。

```js
`複数行の
文字列を
入れたい`; // => "複数行の\n文字列を\n入れたい"
```

- テンプレートの機能もあり、`${変数名}`で変数の値を埋め込める。

```js
const str = "文字列";
console.log(`これは${str}です`); // => "これは文字列です"
```

- 文字列の中に`` ` ``(バッククォート)を内包したい場合は`\`でエスケープが必要。

```js
`This is \`code\``; // => "This is `code`"
```

### null リテラル

- `null`値(値がないこと)を返すリテラル。
- 未定義の場合は変数を参照できないが、`null`で定義すると参照できる。

```js
const foo = null;
console.log(foo); // => null
```

### undefined はリテラルではない

- `undefined`はただのグローバル変数。
- 同じ undefined という名前のローカル変数を宣言することは可能(非推奨)。

```js
function fn() {
  var undefined = "独自の未定義値"; // undefinedという名前の変数をエラーなく定義できる
  console.log(undefined); // => "独自の未定義値"
}
fn();
```

- それに対しリテラルは変数名に使用すると構文エラーになる。

```js
var null; // => SyntaxError
```

### オブジェクトリテラル

- `{}`（中カッコ）を書くことで、新しいオブジェクトを作成できる。

```js
const obj = {}; // 中身が空のオブジェクトを作成
```

- オブジェクトの作成と同時に中身の定義もできる。
  - キーと値を`:`で区切る。

```js
const obj = {
  key: "value",
};
```

- プロパティ名: オブジェクトが持つキーのこと。

  - 上記の例だと、`obj`というオブジェクトは`key`というプロパティを持つといえる。

- `obj`の`key`プロパティの参照は２種類ある。
  - `.`でつなぐ
    - プロパティ名が識別子である必要がある
  - `[]`（ブラケット）

```js
const obj = {
  key: "value",
};
// ドット記法
console.log(obj.key); // => "value"
// ブラケット記法
console.log(obj["key"]); // => "value"
```

- プロパティ名が識別子でない場合

```js
// プロパティ名は文字列の"123"
var object = {
    "123": "value"
};
// OK: ブラケット記法では、文字列として書くことができる
console.log(object["123"]); // => "value"
// NG: ドット記法では、数値からはじまる識別子は利用できない
object.123
```

### 配列リテラル

- `[`と`]`で値をカンマ区切りで囲み、その値を持つ Array オブジェクトを作成するリテラル。
- 配列（Array オブジェクト）: 複数の値に順序をつけて格納できるオブジェクトの一種。

```js
const emptyArray = []; // 空の配列を作成
const array = [1, 2, 3]; // 値を持った配列を作成
```

- `0`からはじまるインデックスに対応した値を持つ。
- `array[index]`という構文で指定したインデックスの値を参照可能。

```js
const array = ["index:0", "index:1", "index:2"];
// 0番目の要素を参照
console.log(array[0]); // => "index:0"
// 1番目の要素を参照
console.log(array[1]); // => "index:1"
```

### 正規表現リテラル

- `/`（スラッシュ）と`/`（スラッシュ）で正規表現のパターン文字列を囲み、正規表現を表すリテラル。
- 1 文字以上の数字にマッチする正規表現の例は下記のようになる。

```js
const numberRegExp = /\d+/; // 1文字以上の数字にマッチする正規表現
// `numberRegExp`の正規表現が文字列"123"にマッチするかをテストする
console.log(numberRegExp.test("123")); // => true
```

### プリミティブ型とオブジェクト

- リテラルでも表現できる真偽値（Boolean）、数値（Number）、文字列（String）をオブジェクトとして表現する方法がある。
- プリミティブ型の値をラップしたようなオブジェクトであるためラッパーオブジェクトと呼ばれる。
- ラッパーオブジェクトは、
  - `new`演算子と対応するコンストラクタ関数を利用して作成する。
  - 例として、文字列のプリミティブ型に対応するコンストラクタ関数は`String`。
  - `typeof`演算子の結果は`object`となる。
  - `length`プロパティなどのオブジェクトが持つプロパティを参照可能になる。

```js
// 文字列をラップしたStringラッパーオブジェクト
const str = new String("文字列");
// ラッパーオブジェクトは"object"型のデータ
console.log(typeof str); // => "object"
// Stringオブジェクトの`length`プロパティは文字列の長さを返す
console.log(str.length); // => 3
```

- プリミティブ型のデータに対してもオブジェクトのように参照できる仕組みがある。
  - プリミティブ型のデータのプロパティへアクセスする際に、対応するラッパーオブジェクトへ暗黙的に変換してからプロパティへアクセスするため。

```js
// プリミティブ型の文字列データ
const str = "文字列";
// プリミティブ型の文字列は"string"型のデータ
console.log(typeof str); // => "string"
// プリミティブ型の文字列も`length`プロパティを参照できる
console.log(str.length); // => 3
```

- 常にリテラルでプリミティブ型のデータを表現することを推奨されている。
  - ラッパーオブジェクトを明示的に作成するには、リテラルに比べて冗長な書き方が必要なため。
